class SystemException : public runtime_error {
public:
    SystemException(const string& msg) : runtime_error(msg) {}
};

class BookingException : public SystemException {
public:
    BookingException(const string& msg) : SystemException("Booking Error: " + msg) {}
};

struct SimpleDate {
    int day;
    int month;
    int year;

    string toString() {
        stringstream ss;
        ss << day << "/" << month << "/" << year;
        return ss.str();
    }
};

class Customer {
public:
    int id;
    string name;
    string phone;

    Customer(int i, const string& n, const string& p) : id(i), name(n), phone(p) {}
};

class Booking {
public:
    int bookingId;
    int roomId;
    Customer customer;
    SimpleDate checkInDate;

    Booking(int bid, int rid, const Customer& cust, const SimpleDate& ci)
        : bookingId(bid), roomId(rid), customer(cust), checkInDate(ci) {}
};

class Invoice {
public:
    int roomId;
    string guestName;
    double totalCharge;

    Invoice(int r, const string& n, double charge)
        : roomId(r), guestName(n), totalCharge(charge) {}

    void printInvoice() {
        cout << "\n--- INVOICE ---\n";
        cout << "Room: " << roomId << ", Guest: " << guestName << endl;
        cout << "Total: $" << totalCharge << endl;
        cout << "---------------\n";
    }
};

class Feedback {
public:
    int roomId;
    int rating;
    string comment;

    Feedback(int r, int rate, const string& c) : roomId(r), rating(rate), comment(c) {}

    void show() {
        cout << "[FEEDBACK] Room " << roomId << " rated " << rating << "/5." << endl;
    }
};

class IRoomManager {
public:
    virtual void checkIn(int roomId, const string& guestName, const SimpleDate& date) = 0;
    virtual void checkOut(int roomId, const SimpleDate& date) = 0;
    virtual ~IRoomManager() = default;
};

class IService {
public:
    virtual void execute(const string& details) = 0;
    virtual string getName() = 0;
    virtual ~IService() = default;
};

class TransportService : public IService {
public:
    string getName() override { return "Transport"; }
    void execute(const string& details) override {
        cout << "[Transport] Request processed for: " << details << endl;
    }
};

class SecurityGuard : public IService {
public:
    string getName() override { return "Security"; }
    void execute(const string& details) override {
        cout << "[Security] Guard sent to: " << details << endl;
    }
};

class LaundryService : public IService {
public:
    string getName() override { return "Laundry"; }
    void execute(const string& details) override {
        cout << "[Laundry] Items collected from: " << details << endl;
    }
};


class HotelManager : public IRoomManager {
private:
    vector<int> occupiedRooms;
    vector<IService*> services;

    bool isOccupied(int roomId) {
        return find(occupiedRooms.begin(), occupiedRooms.end(), roomId) != occupiedRooms.end();
    }

    void notify(const string& message) { // Simple Notification
        cout << "NOTIFICATION: " << message << endl;
    }

public:
    HotelManager() {
        services.push_back(new TransportService());
        services.push_back(new SecurityGuard());
        services.push_back(new LaundryService());
    }

    ~HotelManager() { 
        for (IService* service : services) { delete service; }
    }

    void checkIn(int roomId, const string& guestName, const SimpleDate& date) override {
        if (isOccupied(roomId)) {
            throw BookingException("Room " + to_string(roomId) + " is already busy.");
        }
        occupiedRooms.push_back(roomId);
        cout << "CHECK IN OK: " << guestName << " -> Room " << roomId << "." << endl;
        notify("Check-in for Room " + to_string(roomId));
    }

    void checkOut(int roomId, const SimpleDate& date) override {
        if (!isOccupied(roomId)) {
            throw BookingException("Room " + to_string(roomId) + " is vacant.");
        }
        occupiedRooms.erase(remove(occupiedRooms.begin(), occupiedRooms.end(), roomId), occupiedRooms.end());
        cout << "CHECK OUT OK: Room " << roomId << " available." << endl;
        notify("Check-out for Room " + to_string(roomId));
    }
    
    void requestService(const string& serviceName, const string& details) {
        for (IService* service : services) {
            if (service->getName() == serviceName) {
                service->execute(details);
                return;
            }
        }
        cout << "SERVICE ERROR: " << serviceName << " not recognized." << endl;
    }
};

class Receptionist {
private:
    HotelManager& manager;
    vector<Booking> bookings;

public:
    Receptionist(HotelManager& mgr) : manager(mgr) {}

    void handleCheckIn(const Booking& booking) {
        try {
            manager.checkIn(booking.roomId, booking.customer.name, booking.checkInDate);
        } catch (const BookingException& e) {
            cerr << "[RECEPTIONIST] Failed: " << e.what() << endl;
        }
    }

    void handleCheckout(int roomId, double charge) {
        SimpleDate today = {16, 11, 2025}; // Placeholder date
        try {
            manager.checkOut(roomId, today);
            Invoice bill(roomId, "GuestName", charge);
            bill.printInvoice();
        } catch (const BookingException& e) {
            cerr << "[RECEPTIONIST] Failed: " << e.what() << endl;
        }
    }
};


